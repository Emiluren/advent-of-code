let input = """
  #################################################################################
  #l....#.........#.....#.....#...........#...........#.......#...#...............#
  #.#.###.#####.#.#####.#.###.#.###.#####.#.#.#########.#####.#.#.#.#####.#.#######
  #.#.....#.#...#i......#.#...#.Z.#.....#.#.#e......A...#...#.#.#..q#...#.#.#.....#
  #.#####.#.#.###########.#.###.#######.###.#########.#####.#.#.#####.#.#.###.###.#
  #.#...#.#.#.....#...#...#.....#.....#...#...#.....#.......#.#...#...#.#.#.....#.#
  #.#.#.#.#.#####.#.#.#.#########.###.###.#.###.###.#######.#.#.###.###.#.#.#####F#
  #.#.#.#.......#...#.#.#.#.......#.....#.#.#...#.#...#.....#.#.#...#.#...#u..#...#
  #.#.#.#############.#.#.#.###########.#.###.###.###.###.###.#.#.###.###.###.#.#.#
  #.#.#...............#.#.#.....#...#...#.#...#.....#...#.#.#...#.#.........#.#.#.#
  #.#.###############.#.#.#####.#.#.###.#.#.###.#######.#.#.#####.#####.#####.#.###
  #.#...#.......#.#...#...#...#...#...#.#.#...#.#...#...#.#.N...#.....#...#...#...#
  #####.#.#####.#.#.#####.###.#####.#.#.#.###.#.#.#.#.###.#.#.#######.###.#.#####.#
  #.....#.#.....#.#...#.......#...#.#.#.#.#...#...#.#.#...#.#...#...#...#.#.#.#...#
  #.#####.#.#####T###.#.#######.#.###.#.#.#.###.###.#.###.#.###.#.#.###.###.#.#.#.#
  #.......#.#.........#...#.....#.....#.#.#...#.#...#...#.#..x#...#.#...#...#.#.#.#
  #.#######.###########.###.###########.#.###.###.#.###.#.#########.#.###.###.#.#.#
  #.#...#...#.......#...#...#.......#...#d#.#.#...#...#.#...#.......#.........#.#.#
  #.###.#.###.#####.#.###.###.#####.#.###.#.#.#.#####.#.###.#.###.#######.#####J#.#
  #.....#g..#.#...#.#...#.#.#...#...#...#.#.#...#...#.#.#.....#.S.#.....#.#.....#.#
  #####.###.#.###.#.#.###.#.#.#.#.#####.#.#.#####.###.#.###.#####.#.###.###.#######
  #.......#.......#.#.#...#.#.#.#...#...#.#...#.......#...#.#...#.#...#...#.......#
  #############.###.#.#####.#.#.###.#.###.###.#.#########.###.#######.###.#.#####.#
  #.........#...#...#.....#.#.#.#.#.#.#...#...#.#...#...#...#.........#...#.#.#...#
  #.#######.###.#.#######.#.#.#.#.#.#.#.#B#.###.#.#.#.#.###.###########.###.#.#.#.#
  #.#.....#...#.#.......#.#.#.#.#...#.#.#.#.....#.#.#.#...#...........#.#...#.#.#.#
  #.###.#.###.#######.#.#.#.#.#.#.###.###.#.#####.#.#.#.#.#########.#.#.#.###.#.###
  #...#.#...#...#...#.#...#...#.#.#...#...#.#.....#...#.#.#.....#.#.#.#.#.....#...#
  ###.#.#.#####.#.#.#.#####.###.#.#.###.###.###########.#.###.#.#.#.#.#G#########.#
  #...#.#.#...#...#.#...#...#...#.#.#.....#.#.........#.#.....#.#.#.#.#.....#.....#
  #.###.#.#.#.#####.###.#####.#.###.#.###.#.#.#######.#.#######.#.#.#######.#.###.#
  #.#...#...#.....#...#.......#.#...#.#...#.#.#...#.#.#.....#.#.#.#.......#.#...#.#
  #.#########.#.#.###.###.#######.###.#.#.#.#.#.#.#.#.###.#.#.#.#.#######.#.#.#.###
  #.#.......#.#.#.#.#.#...#.......#...#.#.#.#...#.#.#...#.#.#.#.....#.#...#.#.#...#
  #.#.#####.###.#.#.#.#####.###########.#.#.#.###.#.###.#.#.#.#####.#.#.###.#.###P#
  #.#...#.#.....#.#.#...#...#...........#.#.#...#.#...#.#.#.#.......#.#.....#.#...#
  #.###.#.#######.#.###.#.#########.#####.#.#####.#.#.#.###.#.#######.#########.#.#
  #...#.#...#.....#...#...#.......#...#...#...#...#.#.#.#...#...#...#...#.......#.#
  ###.#.#.###.#####.#.#####.#####.###.#.#####.#.###.###.#.#####.#.#.#.#.###.#####.#
  #w....#...........#.......#.........#..@#@....#.........#.......#...#.....#.....#
  #################################################################################
  #...........#...K...#.......#.......#..@#@#.....#.........#.......#.............#
  #.#######.###.#.#####.#####.#.###.###.#.#.#.#.###.#####.###.#.#.###.###########.#
  #p......#.#...#.......#...#.#...#.#...#.#...#.........#.....#.#.#...#.........#.#
  #######.#.#.###########.#.#.###.#.#.###.#.###################.###.###.#.###.###.#
  #y....#.#...#.#.......#.#.#...#.#...#.#.#...#...#.#.........#.....#...#...#.#...#
  #.#.###.#####.#.###.#.#.#.#.#.#.#####.#.###.#.#.#.#.#######.#.#####.#####.###.#.#
  #.#.#...#...#...#...#.#h#...#.#...#...#.#.#.#.#.#.#.#...#...#.....#.#...#.#...#.#
  #.#.#.###.#.#.###.#####.###.#####.#.###.#.#.#.#.#.#.#.#.###.#####.###.#.#.#.###.#
  #.#.#.....#.#...#...#...#...#...#...#...#.#.#.#...#.#.#...#.....#.#...#...#.#...#
  #M#.#######.###.###.#.###.###.#.#.###.###.#.#.###.#.#.###.#####.#.#.#####.#.#####
  #.#.#.....#.#...#...#...#...#.#...#...#.#b..#...#.#...#z#.#.....#...#...#.#.....#
  #.###.#.#.#.#####.#####.#####.#####.###.#.###.#.#######.#.#####.#####.###.#####.#
  #...#.#.#.#.....#.....#.#...#.#.....#...#.#...#.........#.....#.#.#.........#...#
  ###.#.#.#.#####.###.#.#.#.#.#.#.#####.#.#.#####.#######.#####.#.#.#.#######.#.#.#
  #...#.#.#.....#.....#.#...#...#...#...#.#.#...#.......#.....#.#.#...#...#...#.#.#
  #.###O#.#####.#######.#######D###.#.###.#.#.#.###########.#.#.#.#####.#.#####H#.#
  #.#...#.#.........#.....#...#...#.#...#.#...#.............#.#.#.......#.#...#.#.#
  #.#.###.###########.#####.#.#####.###.#.###.#############.###.#########.#.#.#.#.#
  #.#.#.#.#...#.......#.....#.......#...#.#...#.....#.......#...#.....#.....#...#k#
  #.#.#.#.#.#.#.#######.#############.#####.###.###.#########.###.###.###########.#
  #...#.#...#.#f#.....#.#.......#...#.....#.#...#.#.......#...#...#.#...#.....#.#.#
  #.###.#####.#.#####.###.#####.#.#.#####.###.###.#######.#.#######.###.#.###.#.#.#
  #.#...#..r..#.....#.....#.....#.#.......#...#.....#...#...#.........#...#...#.#.#
  #.###.#V###.#####.#.#####.#####.#######.#.#######.#.#.###.#.#######.#####.###.#.#
  #.#...#...#.....#...#...#...#...#.....#.#.#.....#.#.#.....#.....#.....#...#.....#
  #.#.#####.#####.#####.#.###.###.#.#####.#.#.###.#.#.###########.#.###.#E###.#####
  #m#.#.....#.#.....R...#..o#.#...#.#...#.#.#.#...#...#.........#.#.#.#.#.#.#...#.#
  #.#.#.#####.#.###########.#.#.###.#.#.#.#.#.#.#######.#######.#.#.#.#.#.#.###.#.#
  #...#.#.......#.....#...#.#.#.#.#...#.#.#...#.........#...#.#.#.#.#...#.#...#.#.#
  #.###.#######.#.###.###.#.#.#.#.#.###.#.###############.#.#.#.#.#.#####.###.#.#.#
  #.#...#.....#.#...#...#...#.#.#...#...#.#.........#.....#...#.I.#.#.Q.#...#.#...#
  #.#.###.###.#####.###.#####.#.#.###.###.#.###.#####.###.###.#####.#.#.###.#.###.#
  #.#v#...#.#.....#n..#.#...#.#.#...#.L...#...#.#.....#.#.#..j....#...#.#...#...#.#
  #.#.#X###.#####.###.#.#.#.#.#.###.#########.#.#.#####.#.#.###########.#.###.#.#.#
  #.#...#...Y.#.#.....#s#.#.#...#.#...#...#.#.#...#.....#.#...#.........#...#.#...#
  #.#####.###.#.#######.#.#.#####.###.###.#.#.#####.###.#.#####.###########.#.#####
  #.#.......#.#.....#.#.#.#.#.......#...#.#...#.....#.#.#.....#..a..........#.W...#
  #.#######.#.###.#C#.#.#.#.#.###.#####.#.#.###.#####.#U#####.###################.#
  #.........#c....#...#...#.....#.........#.....#t..........#.....................#
  #################################################################################
  """

// Queue type comes from https://github.com/raywenderlich/swift-algorithm-club/blob/master/Queue/Queue-Optimized.swift
// used under the MIT license
public struct Queue<T> {
    fileprivate var array = [T?]()
    fileprivate var head = 0

    public var isEmpty: Bool {
        return count == 0
    }

    public var count: Int {
        return array.count - head
    }

    public mutating func enqueue(_ element: T) {
        array.append(element)
    }

    public mutating func dequeue() -> T? {
        guard let element = array[guarded: head] else { return nil }

        array[head] = nil
        head += 1

        let percentage = Double(head)/Double(array.count)
        if array.count > 50 && percentage > 0.25 {
            array.removeFirst(head)
            head = 0
        }

        return element
    }

    public var front: T? {
        if isEmpty {
            return nil
        } else {
            return array[head]
        }
    }
}

extension Array {
    subscript(guarded idx: Int) -> Element? {
        guard (startIndex..<endIndex).contains(idx) else {
            return nil
        }
        return self[idx]
    }
}

let inputMap = input.split(separator: "\n").map { Array($0) }

let startRow1: Int = inputMap.firstIndex(where: { $0.contains("@") }) ?? 0
let startCol1: Int = inputMap[startRow1].firstIndex(of: "@") ?? 0

let startRow2 = startRow1 + 2
let startCol2 = startCol1 + 2

struct GraphState: Hashable {
    var positions = [
      (startRow1, startCol1),
      (startRow1, startCol2),
      (startRow2, startCol1),
      (startRow2, startCol2),
    ]
    var keys: Set<Character> = []
    var movingBot: Int

    init(movingBot: Int) {
        self.movingBot = movingBot
    }

    static func == (lhs: GraphState, rhs: GraphState) -> Bool {
        for i in 0..<4 {
            let (lhsRow, lhsCol) = lhs.positions[i]
            let (rhsRow, rhsCol) = rhs.positions[i]

            if lhsRow != rhsRow || lhsCol != rhsCol {
                return false
            }
        }

        return lhs.keys == rhs.keys && lhs.movingBot == rhs.movingBot
    }

    func hash(into hasher: inout Hasher) {
        for pos in positions {
            let (r, c) = pos
            hasher.combine(r)
            hasher.combine(c)
        }
        hasher.combine(movingBot)
        hasher.combine(keys)
    }
}

let allKeys = Set(input.filter { $0.isLetter && $0.isLowercase })

func adjacentPositions(_ pos: (Int, Int)) -> [(Int, Int)] {
    let (r, c) = pos
    return [
      (r, c - 1),
      (r, c + 1),
      (r - 1, c),
      (r + 1, c),
    ];
}

func breadthFirstSearch() -> Int? {
    var queue = Queue<GraphState>()
    var distanceTo = [GraphState: Int]()
    var discovered: Set<GraphState> = []

    for i in 0..<4 {
        let startState = GraphState(movingBot: i)
        distanceTo[startState] = 0
        discovered.insert(startState)
        queue.enqueue(startState)
    }

    while let state = queue.dequeue() {
        let stateDist: Int! = distanceTo[state]

        if state.keys == allKeys {
            return stateDist
        }

        func pushNewState(_ newState: GraphState) {
            if discovered.contains(newState) {
                return
            }

            discovered.insert(newState)
            distanceTo[newState] = stateDist + 1
            queue.enqueue(newState)
        }

        for (r, c) in adjacentPositions(state.positions[state.movingBot]) {
            var newState = state
            newState.positions[state.movingBot] = (r, c)
            let char = inputMap[r][c]
            var foundKey = false

            switch char {
            case "#":
                continue
            case "a"..."z":
                newState.keys.insert(char)
                foundKey = true
            case "A"..."Z":
                let charLower = char.lowercased()
                if !newState.keys.contains(charLower[charLower.startIndex]) {
                    continue
                }
            case ".", "@":
                break
            default:
                print("Unknown tile \(char)!")
                continue
            }

            if foundKey {
                for i in 0..<4 {
                    newState.movingBot = i
                    pushNewState(newState)
                }
            } else {
                pushNewState(newState)
            }
        }
    }

    return nil
}

print("Part 2: \(String(describing: breadthFirstSearch()))")
